<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法-算法简介</title>
      <link href="posts/55342.html"/>
      <url>posts/55342.html</url>
      
        <content type="html"><![CDATA[<h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><h3 id="事前分析估算方法"><a href="#事前分析估算方法" class="headerlink" title="事前分析估算方法"></a>事前分析估算方法</h3><blockquote><p>在计算机程序编写之前，依据<strong>统计方法</strong>对算法进行估算</p></blockquote><p>高级编程语言编写的程序在计算机上运行所消耗的时间取决于下列因素：</p><ol><li> 算法采用的策略，方案</li><li> 编译产生的代码质量</li><li> 问题的输入规模</li><li> 机器执行指令的速度</li></ol><p>抛开计算机之间具有差异性的硬件、软件部分，一个程序的运行时间依赖于<strong>算法的好坏</strong>以及<strong>问题的输入规模</strong></p><p>求 <code>1</code> 到 <code>100</code> 所有数的合</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 第一种算法</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">// 执行1次</span><span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 执行n+1次</span>sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span><span class="token comment">// 执行n次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 第二种算法</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">// 执行1次</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">+</span> n <span class="token punctuation">)</span> <span class="token operator">*</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 执行1次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一种算法执行了 1+(n+1)+n = <strong>2n+2</strong>次</p><p>第二种算法执行了 1+1 = <strong>2</strong>次</p><p>研究算法复杂度，侧重的是研究算法随着输入规模扩大增长量的一个<strong>抽象</strong>，而不是精确地定位需要执行多少次</p><p>抽象指的是 评估一个算法不关心所用的语言是什么，也不关心程序跑在什么样的硬件上，只关心实现的算法是什么</p><p>抽象在具体算法中，也会<strong>忽略</strong>程序中的递增、循环终止条件、变量声明、打印结果等等操作，只把程序看成是独立于程序设计语言的一系列步骤</p><h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><p>做一个测试： </p><p>算法A <strong>2n+2</strong>次操作</p><p>算法B <strong>3n+1</strong>次操作</p><p>A、B 两个算法哪个更快呢？</p><table><thead><tr><th>输入规模</th><th align="center">算法A1（ 2n+3 ）</th><th align="center">算法A2（ 2n ）</th><th align="center">算法B1（ 3n+1 ）</th><th align="center">算法B2（ 3n ）</th></tr></thead><tbody><tr><td>n = 1</td><td align="center">5</td><td align="center">2</td><td align="center">4</td><td align="center">3</td></tr><tr><td>n = 2</td><td align="center">7</td><td align="center">4</td><td align="center">7</td><td align="center">6</td></tr><tr><td>n = 3</td><td align="center">9</td><td align="center">6</td><td align="center">10</td><td align="center">9</td></tr><tr><td>n = 10</td><td align="center">23</td><td align="center">20</td><td align="center">31</td><td align="center">30</td></tr><tr><td>n = 100</td><td align="center">203</td><td align="center">200</td><td align="center">301</td><td align="center">300</td></tr></tbody></table><p>随着输入规模越来越大后，只有<strong>最高项式的阶数</strong>与增长率相关，与<strong>各项式的系数</strong>以及其他<strong>非最高次项式</strong>都可<strong>忽略</strong></p><blockquote><p>多项式的增长率排名： <code>n^n</code> <code>&gt;</code> <code>n^2</code> <code>&gt;</code> <code>2n</code> <code>&gt;</code> <code>2</code></p><p>PS: <code>2</code> 泛指任意常数</p></blockquote><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一般使用大写 <strong>O()</strong> 来体现算法时间复杂度的激发，称之为 <strong>大O记法</strong></p><p>一般情况下，随着输入规模 <code>n</code> 的增大，函数增长最慢的算法为最优算法</p><h3 id="分析一个算法的时间复杂度"><a href="#分析一个算法的时间复杂度" class="headerlink" title="分析一个算法的时间复杂度"></a>分析一个算法的时间复杂度</h3><ol><li>用 <code>常数1</code> <strong>取代</strong>运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，<strong>只</strong>保留最高阶项</li><li>如果最高阶项存在且不是1，则<strong>去除</strong>与这个项相乘的常数</li><li>得到的最终结果就是<strong>大O阶</strong></li></ol><h3 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">int</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love zyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love zyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love zyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love zyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love zyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love zyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">+</span> n <span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度？ <strong>O(8)</strong> ？</p><p>错误的理解，认为有多少条语句就有多少复杂度</p><p>但是其实输出语句和问题规模没有关系，不计入时间复杂度（爱不需要时时“挂在嘴边”，而是要行动）</p><p>按照<a href="#%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">分析</a>中第一条，所有加法常数直接给与 <strong>O(1)</strong> 即可</p><h3 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h3><blockquote><p>一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模 <code>n</code> 的扩大，对应计算次数呈直线增长</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">int</span> i <span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码，时间复杂度为 <strong>O(n)</strong> ，因为循环体内的代码需要执行 <code>n</code> 次</p><h3 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h3><blockquote><p>刚才是单个循环结构，如果是嵌套呢？</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">int</span> i <span class="token punctuation">,</span> j <span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love zyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>n</code> 设置为 <code>100</code> ，外层循环每执行一次，内层循环就执行一百次，那总共程序从这两个循环出来，需要执行 <code>100 * 100</code> 次，也就是 <code>n</code> 的平方</p><p>所以，上述代码时间复杂度为 <strong>O(n^2)</strong></p><p>嵌套三层的话也就是 <strong>O(n^3)</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">int</span> i <span class="token punctuation">,</span> j <span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I love zyy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>分析</p><ol><li>当 <code>i = 0</code> 时，内循环执行 <code>n</code> 次</li><li>当 <code>i = 1</code> 时，内循环执行 <code>n - 1</code> 次</li><li>······</li><li>当 <code>i = n - 1</code> 时，内循环执行 <code>1</code> 次</li><li>总的执行次数为 <code>n + ( n - 1 ) + ( n - 2 ) + ... + 1</code> <code>=&gt;</code> <code>n ( n + 1 ) / 2</code></li></ol></li><li><p>该算法就是等差数列求和</p></li><li><p>继续简化执行次数 <code>n ( n + 1 ) / 2</code> <code>=&gt;</code> <code>n ^ 2 / 2 + n / 2</code></p></li><li><p>按照<a href="#%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">分析</a>的方法</p><ul><li>第一条 忽略，该算法不涉及</li><li>第二条 只保留最高项，所以 <code>n / 2</code> 这项去掉</li><li>第三条 去除与最高项相乘的常数</li></ul><p>最终，时间复杂度为 <code>O(n^2)</code></p></li></ul><h3 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h3><blockquote><p>从这里开始更复杂了呦</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>分析</p><ol><li>每次 <code>i * 2</code> 之后，就距离 <code>n</code> 更近一步，假设有 <code>x</code> 个 <code>2</code> 相乘后大于或等于 <code>n</code> ，则会退出循环</li><li>由 <code>2 ^ x = n</code> <code>=&gt;</code> <code>log(2)n</code> </li></ol></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-绪论</title>
      <link href="posts/29538.html"/>
      <url>posts/29538.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>数据结构与算法属于计算机专业必修专业<br>作为所有软件开发的基础，但是如果要学好，要脚踏实地，<strong>欲速则不达</strong><br>不追求于单调的调用接口，想要知道内部实现原理，也是要深入研究 <code>数据结构与算法</code></p></blockquote><hr><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><ul><li><p>程序设计 = 数据结构 + 算法</p></li><li><p>数据元素相互存在的一种或多种特定关系的集合</p></li></ul><hr><h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>数据对象中数据元素之间的相互关系</p><ul><li><p>集合结构</p><p>同属于一个集合，元素之间<code>没有互相关系</code></p></li><li><p>线性结构</p><p>元素之间存在<code>一对一</code>的关系</p></li><li><p>树形结构</p><p>元素之间存在<code>一对多</code>的层级关系</p></li><li><p>图形结构</p><p>元素之间存在<code>多对多</code>的关系</p></li></ul><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>数据的逻辑结构在计算机中的存储形式<br>实际上研究的是如何把数据元素存储在计算机的存储器中<br>存储器主要为<code>内存</code>和<code>外部存储器</code>（硬盘，软盘，光盘等）</p><ul><li><p>顺序存储</p><p><img src="https://raw.githubusercontent.com/SeanDragon/FigureBed/master/typoraimage-20201125214051383.png"></p><p>数据元素存放在地址连续的存储单元里，数据间的逻辑关系和物理关系是<code>一致的</code></p></li><li><p>链式存储</p><p><img src="http://seandragon-blog.test.upcdn.net/image-20201125214151256.png"></p><p>面对<code>时常变化</code>的场景</p><p>数据元素存放在任意地址的存储单元里，这组存储单元可以是<code>连续的</code>，也可以是<code>不连续的</code></p><p>元素内部需要存放<code>地址的指针</code>，通过地址找到相关联元素的位置</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启示</title>
      <link href="posts/30908.html"/>
      <url>posts/30908.html</url>
      
        <content type="html"><![CDATA[<p>是时候重返少年了，加油吧。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
