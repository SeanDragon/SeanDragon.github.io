---
title: 数据结构与算法-算法简介
abbrlink: 55342
date: 2020-11-25 23:23:18
top: true
mathjax: true
tags: [编程]
categories: [数据结构与算法]
---

## 算法效率的度量方法

### 事前分析估算方法

> 在计算机程序编写之前，依据**统计方法**对算法进行估算

高级编程语言编写的程序在计算机上运行所消耗的时间取决于下列因素：

1.  算法采用的策略，方案
2.  编译产生的代码质量
3.  问题的输入规模
4.  机器执行指令的速度

抛开计算机之间具有差异性的硬件、软件部分，一个程序的运行时间依赖于**算法的好坏**以及**问题的输入规模**

求 `1` 到 `100` 所有数的合

```c
// 第一种算法
int i, sum = 0 , n = 100;			// 执行1次
for( i = 1 ; i <= n ; i++ ) {		// 执行n+1次
	sum = sum + i;					// 执行n次
}
```

```c
// 第二种算法
int sum = 0 , n = 100;			// 执行1次
sum = ( 1 + n ) * n / 2;		// 执行1次
```

第一种算法执行了 1+(n+1)+n = **2n+2**次

第二种算法执行了 1+1 = **2**次

研究算法复杂度，侧重的是研究算法随着输入规模扩大增长量的一个**抽象**，而不是精确地定位需要执行多少次

抽象指的是 评估一个算法不关心所用的语言是什么，也不关心程序跑在什么样的硬件上，只关心实现的算法是什么

抽象在具体算法中，也会**忽略**程序中的递增、循环终止条件、变量声明、打印结果等等操作，只把程序看成是独立于程序设计语言的一系列步骤

### 函数的渐近增长

做一个测试： 

算法A **2n+2**次操作

算法B **3n+1**次操作

A、B 两个算法哪个更快呢？

| 输入规模 | 算法A1（ 2n+3 ） | 算法A2（ 2n ） | 算法B1（ 3n+1 ） | 算法B2（ 3n ） |
| -------- | :--------------: | :------------: | :--------------: | :------------: |
| n = 1    |        5         |       2        |        4         |       3        |
| n = 2    |        7         |       4        |        7         |       6        |
| n = 3    |        9         |       6        |        10        |       9        |
| n = 10   |        23        |       20       |        31        |       30       |
| n = 100  |       203        |      200       |       301        |      300       |

随着输入规模越来越大后，只有**最高项式的阶数**与增长率相关，与**各项式的系数**以及其他**非最高次项式**都可**忽略**

> 多项式的增长率排名： `n^n` `>` `n^2` `>` `2n` `>` `2`
>
> PS: `2` 泛指任意常数

## 算法时间复杂度

### 概念

一般使用大写 **O()** 来体现算法时间复杂度的激发，称之为 **大O记法**

一般情况下，随着输入规模 `n` 的增大，函数增长最慢的算法为最优算法

### 分析一个算法的时间复杂度

1. 用 `常数1` **取代**运行时间中的所有加法常数
2. 在修改后的运行次数函数中，**只**保留最高阶项
3. 如果最高阶项存在且不是1，则**去除**与这个项相乘的常数
4. 得到的最终结果就是**大O阶**

### 常数阶

```go
int sum = 0 , n = 100;
println("I love zyy");
println("I love zyy");
println("I love zyy");
println("I love zyy");
println("I love zyy");
println("I love zyy");
sum = ( 1 + n ) * / 2;
```

时间复杂度？ **O(8)** ？

错误的理解，认为有多少条语句就有多少复杂度

但是其实输出语句和问题规模没有关系，不计入时间复杂度（爱不需要时时“挂在嘴边”，而是要行动）

按照[分析](#分析一个算法的时间复杂度)中第一条，所有加法常数直接给与 **O(1)** 即可

### 线性阶

> 一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模 `n` 的扩大，对应计算次数呈直线增长

```go
int i , n = 100 , sum = 0;
for( i = 0 ; i < n ; i++ ) {
  sum = sum + i;
}
```

上述代码，时间复杂度为 **O(n)** ，因为循环体内的代码需要执行 `n` 次

### 平方阶

> 刚才是单个循环结构，如果是嵌套呢？

```go
int i , j , n = 100;
for ( i = 0 ; i < n ; i++ ) {
  for (j = 0 ; j < n ; j++ ) {
    println("I love zyy");
  }
}
```

如果 `n` 设置为 `100` ，外层循环每执行一次，内层循环就执行一百次，那总共程序从这两个循环出来，需要执行 `100 * 100` 次，也就是 `n` 的平方

所以，上述代码时间复杂度为 **O(n^2)**

嵌套三层的话也就是 **O(n^3)**

```go
int i , j , n = 100;
for ( i = 0 ; i < n ; i++ ) {
  for (j = i ; j < n ; j++ ) {
    println("I love zyy");
  }
}
```

- 分析

  1. 当 `i = 0` 时，内循环执行 `n` 次
  2. 当 `i = 1` 时，内循环执行 `n - 1` 次
  3. ······
  4. 当 `i = n - 1` 时，内循环执行 `1` 次
  5. 总的执行次数为 `n + ( n - 1 ) + ( n - 2 ) + ... + 1` `=>` `n ( n + 1 ) / 2`

- 该算法就是等差数列求和

- 继续简化执行次数 `n ( n + 1 ) / 2` `=>` `n ^ 2 / 2 + n / 2`

- 按照[分析](#分析一个算法的时间复杂度)的方法

  - 第一条 忽略，该算法不涉及
  - 第二条 只保留最高项，所以 `n / 2` 这项去掉
  - 第三条 去除与最高项相乘的常数

  最终，时间复杂度为 `O(n^2)`

### 对数阶

> 从这里开始更复杂了呦

```go
int i = 1 , n = 100;
for ( i < n) {
  i = i * 2;
}
```

- 分析
  1. 每次 `i * 2` 之后，就距离 `n` 更近一步，假设有 `x` 个 `2` 相乘后大于或等于 `n` ，则会退出循环
  2. 由 `2 ^ x = n` `=>` `log(2)n` 

- 

